# FounderOS — Cursor Agent Rules

You are building FounderOS, a knowledge base + milestone tracker + accountability diary for startup founders. This is a real product, not a toy. Write code that a senior engineer at a dev shop would review and say "this is clean."

## Project Overview

FounderOS is a cross-platform app (iOS, Android, web) with three core features:
1. **Knowledge Base + RAG:** Upload documents (PDFs, markdown). The system chunks them, generates embeddings, stores them in pgvector. Users chat with an AI that answers ONLY from their uploaded documents.
2. **Milestone Tracker:** Visual board of project phases and sub-milestones. Tap to mark complete. Progress bars per phase. Shared between founders.
3. **Accountability Diary:** Daily log entries tied to milestones. Each entry: date, author, milestone reference, description of work done. Timeline view with filtering.

## Tech Stack (do NOT deviate)

- **Frontend:** Expo (React Native) + TypeScript. Expo Router for file-based navigation. Targets iOS, Android, and web from one codebase.
- **Backend:** Python 3.12+ with FastAPI. Poetry for dependency management. Pydantic v2 for all request/response schemas.
- **Database:** Supabase (managed PostgreSQL). pgvector extension for embeddings. Supabase Auth for authentication. Supabase Storage for file uploads.
- **AI/Embeddings:** OpenAI API (text-embedding-3-small for embeddings, gpt-4o for chat). LangChain is NOT allowed — use the OpenAI SDK directly. Keep it simple.
- **PDF Processing:** `unstructured` library for PDF parsing and chunking.
- **Hosting:** DigitalOcean Droplet (Ubuntu 24.04) running PostgreSQL + pgvector + FastAPI behind Nginx with HTTPS (Let's Encrypt). This is a production app, not a local-only project.
- **Frontend Distribution:** Expo EAS for development builds and OTA updates. Both founders install via QR code/link, get JS updates in minutes without App Store review.
- **Real-Time Sync:** TanStack React Query with 5-second polling on active screens. Changes on one device appear on the other within seconds.
- **CI/CD:** GitHub Actions. On push to main: lint, test, SSH into Droplet, pull, install, migrate, restart service.
- **Local Dev:** Docker Compose for running PostgreSQL + pgvector locally during development. The Expo dev server runs natively (not in Docker).

## Architecture Rules

### Backend (FastAPI)
- All routes live in `app/routers/`. One file per domain: `documents.py`, `milestones.py`, `diary.py`, `chat.py`, `auth.py`.
- All Pydantic schemas live in `app/schemas/`. One file per domain. Request and response models are separate classes.
- All database models live in `app/models/`. Use SQLAlchemy 2.0 style with mapped_column.
- Business logic lives in `app/services/`. Routers call services, services call the database. Routers never contain business logic.
- All config from environment variables via `app/config.py` using pydantic-settings.
- Every endpoint must have:
  - Type hints on all parameters and return values
  - A Pydantic response model
  - Proper HTTP status codes (201 for creation, 204 for deletion, etc.)
  - Error handling that returns structured JSON errors, never raw tracebacks
- Use `async def` for all route handlers and service methods that do I/O.
- Use dependency injection for database sessions, current user, etc.
- API versioning: all routes prefixed with `/api/v1/`.
- Write docstrings on every public function. Google style.
- Tests use pytest + httpx AsyncClient. One test file per router. Minimum 90% coverage.

### Frontend (Expo + TypeScript)
- Use Expo Router (file-based routing in `app/` directory).
- Strict TypeScript: `"strict": true` in tsconfig. No `any` types. No `// @ts-ignore`.
- Component structure:
  - `app/` — route screens only. Minimal logic, delegates to components.
  - `components/` — reusable UI components. Each component gets its own directory with `index.tsx` and optional `styles.ts`.
  - `hooks/` — custom React hooks. One hook per file.
  - `services/` — API client functions. One file per backend domain. All API calls go through a shared `api.ts` client with auth headers.
  - `types/` — shared TypeScript interfaces/types. Mirror backend schemas.
  - `constants/` — theme colors, spacing, API URLs, etc.
- State management: React Context + useReducer for global state (auth, user). No Redux. TanStack Query (React Query) for server state.
- Styling: StyleSheet.create() — no inline styles, no styled-components, no NativeWind/Tailwind. Keep it simple and native.
- Every component must be typed. Props interfaces defined and exported.
- No default exports except for route screens (Expo Router requires them).
- Use named exports for everything else.

### Database
- All tables use UUID primary keys (generated by PostgreSQL, not the app).
- All tables have `created_at` and `updated_at` timestamps with defaults.
- Use database migrations via Alembic. Never modify the database manually.
- The embeddings table uses pgvector's `vector(1536)` column type (matching text-embedding-3-small dimensions).
- Row Level Security (RLS) is handled at the application layer via FastAPI middleware, not Supabase RLS policies (we want the logic in our code, not in Supabase).

### RAG Pipeline
- PDF upload flow: Upload to Supabase Storage → backend downloads → `unstructured` parses to text → split into chunks (max 512 tokens, 50 token overlap) → generate embeddings via OpenAI → store chunks + embeddings in pgvector.
- Chat flow: User sends question → generate embedding for question → cosine similarity search in pgvector (top 5 chunks) → send chunks + question to GPT-5.2 with system prompt that says "answer ONLY from the provided context" → stream response back to frontend.
- Never send the full document to the LLM. Always use retrieval.

## Coding Standards

### General
- No commented-out code. Delete it.
- No TODO comments without a linked issue/task.
- No print() statements. Use Python's `logging` module (backend) or console.warn only for actual warnings (frontend).
- No magic numbers or strings. Use constants or enums.
- Functions do one thing. If a function is longer than 40 lines, break it up.
- Error messages must be helpful. "Document not found" not "Error 404."

### Naming Conventions
- **Python:** snake_case for variables/functions, PascalCase for classes, UPPER_SNAKE_CASE for constants.
- **TypeScript:** camelCase for variables/functions, PascalCase for components/types/interfaces, UPPER_SNAKE_CASE for constants.
- **Files:** snake_case for Python, kebab-case for TypeScript (except components which are PascalCase).
- **Database tables:** snake_case, plural (documents, milestones, diary_entries, document_chunks).

### Git
- Conventional commits: `feat:`, `fix:`, `refactor:`, `docs:`, `test:`, `chore:`.
- One feature per branch. Branch names: `feat/rag-pipeline`, `fix/auth-redirect`, etc.
- Never commit .env files, node_modules, __pycache__, or .expo/.

## What NOT To Do
- Do NOT use LangChain, LlamaIndex, or any RAG framework. Use OpenAI SDK directly.
- Do NOT use an ORM auto-migration. Use Alembic explicitly.
- Do NOT use Redux, MobX, or Zustand. Use React Context + React Query.
- Do NOT use Tailwind, NativeWind, or styled-components.
- Do NOT use class components. Functional components only.
- Do NOT hardcode API URLs. Use environment variables.
- Do NOT store secrets in code. Use .env files (and .env.example for the template).
- Do NOT skip error handling. Every API call in the frontend must handle loading, error, and success states.
- Do NOT use `fetch` directly in components. All API calls go through the service layer.

## File References
- Read `docs/PROJECT_BRIEF.md` for the full product spec with features and user stories.
- Read `docs/ARCHITECTURE.md` for database schema, API endpoints, and data flow diagrams.
- Follow the scaffold in `apps/api/` and `apps/mobile/` — the directory structure is already set up.

